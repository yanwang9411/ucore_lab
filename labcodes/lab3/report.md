
##练习1 ：给未被映射的地址映射上物理地址


###实现思路：

> > 找到该地址对应的 vma 结构
> > 通过和vma 起始地址的比对，判断该地址是否合法
> > 判断错误码

> > 找到地址对应的页表，如果不存在，则创建一个

> > 若不存在相应的物理地址，则分配一个空闲页，并将物理地址和虚拟地址映射起来

> > 如果pte时swap entry，就从外存的相应位置加载，并将该页表插入，建立physical address 和 逻辑地址的映射

###和参考代码的区别：
无区别


###描述页目录项和页表中组成部分对实现页替换算法的潜在作用：
> > entry 中 present 位表示当前该页是否在内存中，如果在内存中，直接由物理地址访问数据，如果不是，找到相应的扇区。



###如果ucore的缺页服务例程访存时出现了页访问异常，ucore 硬件会做哪些事情：
> > ucore 会认为无法处理该异常，直接kill该进程



##练习2:

###实现：

> > map_swappable :
> > 将最新到达的页加到该内存空间链表的队尾
> >
> > swap_out_victim:
> > 根据fifo 原则，将最先到达的page删去
> > 将空闲下来的page空间赋给ptr_page

###和参考代码的区别：
> > 无区别


###如果要在ucore上实现extended clock页替换算法：

> > 不支持，需要数据结构进行扩展。首先在 pra_list 内存空间链表中需要保存每个entry（page）的dirty情况，即是否被访问，以及被修改。（可以在page结构中扩展，或是直接在mm_struct中扩展）
> >
> > 替换算法： 轮询，替换访问位和dirty位均为0的页，若遇到访问位为1则将其置为1，若遇到访问位为0且dirty位为1 的将dirty位置为0


####需要被换出的页的特征是什么：
> > 访问位为0，dirty bit为0
####在ucore中如何判断具有这样特征的页？
####何时进行换入换出操作：
> > 产生页缺失时

